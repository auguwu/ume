// üêª‚Äç‚ùÑÔ∏èüíê ume: Easy, self-hostable, and flexible image host made in Rust
// Copyright 2021-2025 Noel Towa <cutie@floofy.dev>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::cli::{config::Config, parse_either};
use arboard::ImageData;
use azalia::{config::env, remi::core::Bytes};
use chrono::Local;
use color_eyre::Section;
use either::Either;
use eyre::Context;
use image::{DynamicImage, ImageReader};
use reqwest::multipart::{Form, Part};
use serde_json::Value;
use std::{
    borrow::Cow,
    ffi::OsString,
    fs::{self, remove_file},
    io::Cursor,
    path::{Path, PathBuf},
    process::{Command, Stdio, exit},
};
use url::Url;

#[derive(Debug, Clone, clap::Args)]
pub struct ScreenshotProgram {
    /// Specifies ume to use Gnome Screenshot with an optional binary path
    /// to **gnome-screenshot**.
    #[arg(long = "gnome-screenshot", env = "GNOME_SCREENSHOT", conflicts_with = "flameshot")]
    pub gnome_screenshot: Option<PathBuf>,

    /// Specifies ume to use Flameshot with an optional binary path
    /// to **gnome-screenshot**.
    #[arg(long, env = "FLAMESHOT")]
    pub flameshot: Option<PathBuf>,
}

/// Takes a screenshot and uploads it to a Ume server.
///
/// This command was originally an internal shell script used by Noel
/// and it is now natively implemented in the `ume` binary. It supports
/// using GNOME Screenshot or Flameshot to actually bring a GUI or uses
/// the process' `stdin` to process an image and upload it to a server.
///
/// You can configure the `~/.config/Noel/ume.toml` (or where `~/.config` is
/// on your system) to configure a list of uploaders that can be referenced
/// by the `<SERVER>` property.
#[derive(Debug, Clone, clap::Parser)]
pub struct Cmd {
    /// the server that can be a fully qualified URL or a name that is referenced
    /// in the `config.toml` file.
    #[arg(value_parser = parse_either::<Url, String>)]
    server: Either<Url, String>,

    /// the uploader key either generated by the server or yourself.
    ///
    /// this can be used via the `UME_UPLOADER_KEY` environment variables to not
    /// leak the uploader key in public scripts.
    #[arg(env = "UME_UPLOADER_KEY", default_value = None)]
    uploader_key: Option<String>,

    /// temporary directory to store images when being uploaded by a screenshot
    /// tool.
    #[arg(long, short = 't', env = "UME_TEMPDIR", default_value = None)]
    tempdir: Option<PathBuf>,

    /// The file that should be uploaded to the server.
    #[arg(long, short = 'f', env = "UME_FILE", default_value = None)]
    file: Option<PathBuf>,

    /// whether if ume should copy the URL that the server generated
    /// to the system clipboard or not.
    #[arg(long, env = "UME_NO_COPY", default_value_t = false)]
    no_copy: bool,

    /// the configuration file to load in. by default, it'll load in
    /// `$XDG_CONFIG_DIR/Noel/ume/config.toml` and create a new file
    /// if it doesn't exist.
    #[arg(long, short = 'c', env = "UME_CONFIG_FILE")]
    config: Option<PathBuf>,

    #[cfg(feature = "os-notifier")]
    #[arg(long, env = "UME_ALLOW_SYSTEM_NOTIFICATIONS", default_value_t = true)]
    /// whether if system notifications should be shown or not.
    ///
    /// by default, this is true. but it can also be set to `false` to
    /// disable it or via the main configuration file.
    system_notifications: bool,

    #[command(flatten)]
    screenshotter: ScreenshotProgram,
}

pub async fn execute(mut cmd: Cmd) -> eyre::Result<()> {
    let clipboard = match arboard::Clipboard::new() {
        Ok(board) => Some(board),
        Err(e) => {
            warn!(error = %e, "failed to get system clipboard, setting NOCOPY");

            cmd.no_copy = true;
            None
        }
    };

    let config = Config::load(cmd.config.clone())?;

    #[cfg(feature = "os-notifier")]
    {
        cmd.system_notifications |= config.system_notifications.as_bool();
    }

    let (server, uploader_key) = get_uploader_info(&cmd, &config)?;
    let tempdir = cmd.tempdir.clone().unwrap_or(std::env::temp_dir());
    if !tempdir.join("screenshots").try_exists()? {
        warn!("temporary directory for screenshots doesn't exist, creating!");
        fs::create_dir(tempdir.join("screenshots"))?;
    }

    trace!("temp dir => {}", tempdir.display());
    trace!("server   => {}", server);

    let file = match cmd.file {
        None => {
            let (binary, arguments) = get_screenshotter_args(cmd.screenshotter)?;
            let (mut c, file) = build_process(&tempdir, binary.clone(), arguments)?;
            let output = c.output()?;

            if !output.status.success() {
                error!("failed to run screenshot");
                remove_file(file)?;

                #[cfg(feature = "os-notifier")]
                show_notification(cmd.system_notifications, &config, |notif| {
                    notif.body(&format!(
                        "received status code {} while running command '{}'",
                        output.status.code().unwrap_or(-1),
                        binary.display()
                    ));

                    #[cfg(target_os = "linux")]
                    notif.urgency(notify_rust::Urgency::Critical);
                });

                exit(1);
            }

            file
        }

        Some(path) => path,
    };

    info!(file = %file.display(), "uploading file to server...");

    let client = reqwest::Client::builder()
        .user_agent(format!(
            "auguwu/ume+cli (+https://github.com/auguwu/ume; {})",
            crate::version()
        ))
        .build()
        .unwrap();

    let contents = fs::read(&file).map(Bytes::from)?;

    let ct = azalia::remi::fs::default_resolver(&contents).parse::<mime::Mime>()?;
    assert!(ct.type_() == mime::IMAGE);

    let ext = match ct.subtype() {
        mime::PNG => "png",
        mime::JPEG => "jpg",
        mime::GIF => "gif",
        mime::SVG => "svg",
        _ => unreachable!(),
    };

    let res = client
        .post(server.join("images/upload")?)
        .header("Authorization", &uploader_key)
        .multipart(Form::new().part(
            "fdata",
            Part::stream(contents.clone()).file_name(format!("unknown.{ext}")),
        ))
        .send()
        .await?;

    let status = res.status();
    let bytes = res.bytes().await?;

    let data: Value = match serde_json::from_slice(&bytes) {
        Ok(data) => data,
        Err(e) => {
            error!(error = %e, status.code = %status, "failed to decode data from server into JSON");
            trace!("{}", String::from_utf8_lossy(&bytes));

            return Err(e.into());
        }
    };

    if !data.is_object() {
        error!(%status, "unexpected JSON payload from server: {}", data);

        #[cfg(feature = "os-notifier")]
        show_notification(cmd.system_notifications, &config, |notif| {
            notif.body(&format!(
                "received unexpected JSON payload from server `{}` [status code: {}]",
                server, status
            ));

            #[cfg(target_os = "linux")]
            notif.urgency(notify_rust::Urgency::Critical);
        });
    }

    let obj = data.as_object().unwrap();
    if obj.contains_key("message") {
        let message = obj["message"].as_str().unwrap();

        error!(%status, "received message from server: {message}");

        #[cfg(feature = "os-notifier")]
        show_notification(cmd.system_notifications, &config, |notif| {
            notif.body(&format!("received message from server: {message}"));

            #[cfg(target_os = "linux")]
            notif.urgency(notify_rust::Urgency::Critical);
        });

        if cmd.no_copy || clipboard.is_none() {
            return Ok(());
        }

        let mut clipboard = unsafe { clipboard.unwrap_unchecked() };
        let img: DynamicImage = ImageReader::new(Cursor::new(&contents)).decode()?;

        clipboard.set_image(ImageData {
            height: img.height() as usize,
            width: img.width() as usize,
            bytes: Cow::Borrowed(contents.as_ref()),
        })?;

        fs::remove_file(file).context("unable to delete file")?;
        return Ok(());
    }

    let mut url = obj["filename"].as_str().unwrap().to_owned();
    if !url.starts_with(server.as_str()) {
        url = server.join(&format!("images/{url}"))?.to_string();
    }

    if cmd.no_copy || clipboard.is_none() {
        eprintln!("{url}");

        fs::remove_file(file).context("unable to delete file")?;

        return Ok(());
    }

    info!("opening system clipboard...");
    let mut clipboard = unsafe { clipboard.unwrap_unchecked() };

    #[cfg(target_os = "linux")]
    {
        use arboard::SetExtLinux;
        use std::time::{Duration, Instant};

        // wait ~1s to block
        clipboard
            .set()
            .wait_until(Instant::now() + Duration::from_secs(1))
            .text(&url)?;
    }

    #[cfg(not(target_os = "linux"))]
    clipboard.set_text(&url)?;

    info!("copied to clipboard, deleting image");
    fs::remove_file(file).context("unable to delete file")?;

    #[cfg(feature = "os-notifier")]
    show_notification(cmd.system_notifications, &config, |notif| {
        notif.body(&format!("uploaded image to server: {}", url));
    });

    Ok(())
}

fn get_uploader_info(
    Cmd {
        server, uploader_key, ..
    }: &Cmd,
    config: &Config,
) -> eyre::Result<(Url, String)> {
    match server {
        Either::Left(url) => {
            if uploader_key.is_none() {
                // support {scheme}://:<password>@uploader
                if let Some(password) = url.password() {
                    return Ok((url.clone(), password.to_owned()));
                }

                bail!("expected `<UPLOADER KEY>` argument to be present if `<SERVER>` argument is a valid URI")
            }

            Ok((url.to_owned(), uploader_key.clone().unwrap()))
        }

        Either::Right(name) => {
            let Some(uploader) = config.uploaders.iter().find(|x| x.name.as_str() == name.as_str()) else {
                bail!("uploader by name '{}' doesn't exist", name)
            };

            Ok((uploader.url.clone(), uploader.key.clone()))
        }
    }
}

fn get_screenshotter_args(
    ScreenshotProgram {
        gnome_screenshot,
        flameshot,
    }: ScreenshotProgram,
) -> eyre::Result<(PathBuf, Vec<OsString>)> {
    match (flameshot, gnome_screenshot) {
        (Some(path), None) => {
            path.try_exists().context("path doesn't actually exist")?;

            Ok((path, flameshot_args()))
        }

        (None, Some(path)) => {
            path.try_exists().context("path doesn't actually exist")?;

            Ok((path, gnome_screenshot_args()))
        }

        (None, None) => {
            for (i, bin) in ["flameshot", "gnome-screenshot"].iter().enumerate() {
                if let Ok(bin) = which::which(bin) {
                    return Ok((bin, (i == 0).then(flameshot_args).unwrap_or_else(gnome_screenshot_args)));
                }
            }

            bail!("unable to find either `flameshot` or `gnome-screenshot`")
        }

        _ => unreachable!(),
    }
}

#[cfg(feature = "os-notifier")]
fn show_notification(allow: bool, config: &Config, f: impl FnOnce(&mut notify_rust::Notification)) {
    use crate::cli::config::system_notifications::{self, Settings};

    if !allow {
        return;
    }

    let mut notification = notify_rust::Notification::new();
    f(&mut notification);

    if let system_notifications::Config::Configurable(Settings { timeout }) = config.system_notifications {
        notification.timeout(timeout);
    }

    let _ = notification.show().unwrap();
}

fn build_process(tmpdir: &Path, binary: PathBuf, args: Vec<OsString>) -> eyre::Result<(Command, PathBuf)> {
    let filename = tmpdir
        .join("screenshots")
        .join(format!("{}.png", Local::now().to_rfc3339()));

    let is_flameshot = binary.ends_with("flameshot");

    let mut cmd = Command::new(&binary);
    cmd.args(args);

    if is_flameshot {
        let file = fs::File::create_new(&filename).with_note(|| format!("for file: {}", filename.display()))?;
        cmd.stdout(file.try_clone()?)
            .stderr(Stdio::inherit())
            .stdin(Stdio::null());

        // Inject QT's Wayland flag if we are on Wayland
        // TODO(@auguwu): better detection?
        if env::try_parse::<_, String>("WAYLAND_DISPLAY").is_ok() {
            cmd.env("QT_QPA_PLATFORM", "wayland");
        }
    } else {
        cmd.arg(format!("--file={}", filename.display()));
    }

    let args = cmd.get_args().map(|x| x.to_string_lossy()).collect::<Vec<_>>();
    info!("$ {} {}", binary.display(), args.join(" "));

    Ok((cmd, filename))
}

#[inline]
fn gnome_screenshot_args() -> Vec<OsString> {
    ["--interactive"].into_iter().map(Into::into).collect()
}

#[inline]
fn flameshot_args() -> Vec<OsString> {
    ["gui", "-r"].into_iter().map(Into::into).collect()
}
